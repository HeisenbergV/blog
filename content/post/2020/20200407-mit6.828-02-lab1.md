
---
title: "MIT6.828-02-Lab1.Util"
categories: [code,xv6]
tags: [操作系统,xv6]
date: 2020-04-07
---


## 知识点

## Util
每一个Lab对应一个git 分支，本实验分支为 `util`，主要是实现5个shell小程序。在 `xv6-riscv-fall19`项目里， `kernel`是内核， `user`是用户态程序， 代码写到`user`里，然后再Makefile `UPROGS`变量中加入的相应名称即可：

```Makefile
UPROGS=\
	$U/_sleep\
	$U/_pingpong\
	$U/_primes\
	$U/_find\
	$U/_xargs\
```

我的代码都在 [这里](https://github.com/HeisenbergV/xv6-riscv-fall19/tree/util/user)

执行`make grade`会测试自己写的api，如果执行失败可能是未安装python(apt-get install python)，就像下面一样：
```log
$ make qemu-gdb
OK (5.1s)
sleep, returns:
$ make qemu-gdb
OK (1.1s)
sleep, makes syscall:
$ make qemu-gdb
OK (0.7s)
pingpong:
```
### sleep
`kernel/sysproc.c` 提供了`sleep`接口，只需要进行一次系统调用即可。

**TODO**：程序写完，但在执行命令的时候总是卡死，但测试是通过的，目前还不知道什么原因

```c
#include "kernel/types.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
    if( argc != 2) {
        fprintf(2, "usage: sleep seconds \n");
        exit();
    }
    sleep(atoi(argv[1]));
    exit();
}
```
### pingpong
这个程序主要是：利用`pipe`管道，将一个字节在两个进程间往返：parent进程发送一个字节到parent_fd[1]，child进程从 parent_fd[0]接收；然后再响应将字节回传给parent进程。

```c
#include "kernel/types.h"
#include "user/user.h"

int
main(int argc, char *argv[]) {
    int parent_fd[2],child_fd[2];

    //创建管道 fd[0]读 fd[1]写
    pipe(parent_fd); 
    pipe(child_fd); 

    char msg = '0';
    if(fork() == 0) {//child 进程
        read(parent_fd[0], &msg, 1);//读取
        fprintf(2, "pid-%d: child received ping, msg: %c \n", getpid(), msg);
        write(child_fd[1], &msg, 1);//写入
    } else{ //parent 进程
        write(parent_fd[1], &msg, 1);
        read(child_fd[0], &msg, 1);
        fprintf(2, "pid-%d: parent received pong, msg: %c \n", getpid(), msg);
    }
    exit();
}
```

### primes

### find
### xargs
