---
title: "B-Tree"
categories: [coder]
tags: [算法]
date: 2020-05-05
draft: true

---

# B-Tree
B-Tree 中文是平衡多路查找树，常用的二叉树、二叉搜索树等，查询效率为O(log2N)。B-Tree和它们相比的优势在于IO层面的优化，它将高瘦的二叉树变成了一个矮胖的多叉树。树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，所以矮胖能减少IO读写次数以此提高性能。所以也更适用于数据库、文件等

## 定义
1. 树中每个结点最多含有m个孩子（m>=2）
2. 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（ceil(x)向上取整）
3. 根结点至少有2个孩子（除非B树只包含一个结点：根结点）
4. 所有叶子结点都出现在同一层（整棵树高度一致），叶子结点不包含任何关键字信息，但占据内存空间
5. 除根结点和叶子结点外的节点包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
a) Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。
b) Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。
c) 关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码

### 结构体定义
```go
type BTree struct{
}
```

## Find
比如要查询f
1. 先检查根节点关键字信息[a,b,c]
2. 如果没有向子节点查询：找到c下的指针
3. 循环反复，最终找到结果

## Insert

## Delete